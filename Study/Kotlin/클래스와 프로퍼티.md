---
cssclasses:
  - cornell-left
  - cornell-livepreview
---
* 1. 클래스 기본 문법
* Java에서 person클래스
```java
public class Person {
	private final String name;
	
	public Person(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
}
```
* 기존 Java에서는 필드가 둘 이상으로 늘어나면 생성자 본문에서 필드에 대입하는 대입문도 늘어나게 됨
* Kotlin에서 위 클래스는 아래와 같이 표현 가능
```kotlin
class Person(val name: String)
```
* public 가시성 변경자(visibility modifier)가 사라짐
	* kotlin 기본 가시성이 public이기 때문

* 2. 프로퍼티
* 클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것
* Java에서는 데이터를 필드에 저장, 멤버 필드의 가시성은 보통 private
* 멤버 필드에 접근하기 위해서는 접근자 메서드(access modifier)를 제공하는게 일반적
* Java에서는 필드와 접근자를 묶어 프로퍼티라고 부름
* Kotlin에서는 프로퍼티를 언어 기본 기능으로 제공, Kotlin property는 Java의 필드와 접근자 메서드를 완전히 대체 가능함
```kotlin
class Person(
	val name: String, // 읽기 전용 프로퍼티, Kotlin이 private필드와 public getter 생성해줌
	val isMarried: Boolean, // 쓸 수 있는 프로퍼티, Kotlin이 private 필드와 public getter, public setter를 생성해줌
)
```
* 기본적으로 Kotlin이 프로퍼티를 선언하는 방식은 프로퍼티와 관련된 접근자를 선언하는 방식임
	* 읽기 전용 프로퍼티의 경우 getter만 선언
	* 변경 가능한 프로퍼티의 경우 getter와 setter모두 선언
* Kotlin은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하는 setter, 필드의 값을 읽기 위한 getter로 이루어진 default 접근자 구현을 제공함
* Kotlin으로 생성된 getter와 setter의 java 쪽 네이밍은 필드에 get과 set을 붙이는 규칙이 있음
	* 단 필드 네이밍 자체가 is으로 시작하면 get을 별도로 붙이지 않음(필드명 그대로 getter로 사용)
	* 또한 필드 네이미 자체가 is로 시작하면 is를 set으로 바꾼 이름 사용
``` kotlin
val person = Person("Bob", true)
println(person.name) // 프로퍼티 이름을 직접 사용해도 Koltin이 자동으로 getter호출
println(person.isMarried)  // 프로퍼티 이름을 직접 사용해도 Koltin이 자동으로 getter호출
```

* 2-1. 커스텀 접근자
* 대부분의 프로퍼티는 그 값을 저장하기 위한 필드(backing field)가 있음
* 하지만 원한다면 프로퍼티 값을 그때그떄 계산할 수 있고 이는 커스텀 접근자를 활용해서 그런 프로퍼티를 만들수 있음
```kotlin
class Rectangle(val height: Int, val width: Int) {
	val isSquare: Boolean
		get() { // 프로퍼티 getter선언
			return height == width;
		}
}
```
* 블록을 본문으로 하는 구문 외에도 get() = height == width 의 형태도 가능
* Java에서 이 접근자를 사용하려면 isSquare() 메소드를 호출하면 됨

* 3. Kotlin 소스코드 구조 : 디렉토리와 패키지
* Java에서는 모든 클래스를 패키지 단위로 관리
* Kotlin에서도 비슷한 개념의 패키지가 있음
* 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용 가능
* 다른 패키지에 정의된 선언을 사용하려면 import를 통해 선언을 불러와야 함
* Java와 마찬가지로 import문은 파일의 맨 앞에 오며 import 키워드를 사용함
* Java에서는 디렉토리 구조가 패키지 구조를 그대로 따라야함(예시 필요)
* 반면 Kotlin에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일 이름도 마음대로 정할 수 있음
* 디스크상의 어느 디렉토리에 소스코드 파일을 위치시키든 관계 없음
* 패키지 구조와 디렉토리 구조가 맞아 떨어질 필요없음


> [!cue] Sample of a Summary



> [!summary] Title for summary

