---
createdAt: 2026-02-28
modified: 2026-02-28
topic: Kotlin
---

- Kotlin의 원시 타입과 Java 원시 타입의 관계
- Int, Long, Double 등 기본 숫자 타입
- 숫자 타입 간 변환 규칙
- Any, Unit, Nothing 특수 타입의 역할
- 박싱(Boxing)과 언박싱 동작 방식

---

## 기본 타입

Kotlin은 Java와 달리 원시 타입(primitive type)과 래퍼 타입(wrapper type)을 구분하지 않습니다. 항상 같은 타입을 사용합니다.

```kotlin
val num: Int = 42
val list: List<Int> = listOf(1, 2, 3)
```

### 정수 타입

| 타입 | 크기 | 범위 |
|------|------|------|
| `Byte` | 8비트 | -128 ~ 127 |
| `Short` | 16비트 | -32768 ~ 32767 |
| `Int` | 32비트 | -2^31 ~ 2^31-1 |
| `Long` | 64비트 | -2^63 ~ 2^63-1 |

### 부동소수점 타입

| 타입 | 크기 | 정밀도 |
|------|------|--------|
| `Float` | 32비트 | 소수점 6~7자리 |
| `Double` | 64비트 | 소수점 15~16자리 |

### 기타 기본 타입

| 타입 | 설명 | 예시 |
|------|------|------|
| `Boolean` | 참/거짓 | `true`, `false` |
| `Char` | 단일 문자 | `'A'`, `'한'` |

### 리터럴 표기법

```kotlin
val decimal = 100          // Int
val long = 100L            // Long
val double = 3.14          // Double
val float = 3.14f          // Float
val hex = 0xFF             // 16진수
val binary = 0b1010        // 2진수
val underscore = 1_000_000 // 언더스코어로 가독성 향상
```

---

## 숫자 타입 변환

Kotlin은 숫자 타입 간 **자동 변환(implicit conversion)을 허용하지 않습니다**. 더 큰 타입이라도 자동으로 변환되지 않으며, 반드시 명시적 변환 함수를 호출해야 합니다.

```kotlin
val intVal: Int = 1
val longVal: Long = intVal.toLong()  // 명시적 변환 필요
// val longVal: Long = intVal         // 컴파일 에러!
```

### 변환 함수

| 함수 | 변환 대상 |
|------|----------|
| `toByte()` | Byte |
| `toShort()` | Short |
| `toInt()` | Int |
| `toLong()` | Long |
| `toFloat()` | Float |
| `toDouble()` | Double |
| `toChar()` | Char |

### 예외: 산술 연산에서의 자동 변환

산술 연산자는 적절한 타입의 값을 받아들이도록 오버로드되어 있어 별도 변환이 필요 없습니다.

```kotlin
val longVal = 1L + 1    // Long + Int → Long
val doubleVal = 1.0 + 1 // Double + Int → Double
```

---

## 박싱(Boxing)

Kotlin 컴파일러는 상황에 따라 원시 타입(primitive)과 래퍼 타입(wrapper)을 자동으로 선택합니다.

### 컴파일 시 타입 매핑

| Kotlin 타입 | JVM 바이트코드 | 조건 |
|-------------|--------------|------|
| `Int` | `int` | 널이 아닌 타입으로 사용 시 |
| `Int?` | `java.lang.Integer` | 널 가능 타입 사용 시 |
| `List<Int>` | `List<java.lang.Integer>` | 제네릭 타입 인자로 사용 시 |

```kotlin
val a: Int = 10       // JVM에서 int로 저장
val b: Int? = 10      // JVM에서 Integer로 박싱
val list: List<Int> = listOf(1, 2, 3)  // Integer로 박싱
```

### 동일성과 동등성

박싱된 타입은 참조가 다를 수 있으므로 `===`(참조 비교)와 `==`(값 비교)의 결과가 다를 수 있습니다.

```kotlin
val a: Int = 10000
val boxedA: Int? = a
val anotherBoxedA: Int? = a

println(boxedA == anotherBoxedA)   // true  (값 비교)
println(boxedA === anotherBoxedA)  // false (참조 비교, 다른 객체)
```

---

## 특수 타입

### Any

`Any`는 Kotlin에서 **모든 널이 아닌 타입의 최상위 타입**입니다. Java의 `Object`에 대응합니다.

```kotlin
val value: Any = 42       // Int가 Any로 자동 박싱
val str: Any = "Hello"
```

- 모든 Kotlin 클래스는 `Any`를 상위 타입으로 가짐
- `Any`에는 `equals()`, `hashCode()`, `toString()` 메서드가 정의되어 있음
- 널 가능한 최상위 타입은 `Any?`

### Unit

`Unit`은 Java의 `void`에 대응합니다. 함수가 의미 있는 값을 반환하지 않을 때 사용합니다.

```kotlin
fun printMessage(msg: String): Unit {
    println(msg)
}

// Unit 반환 타입은 생략 가능
fun printMessage(msg: String) {
    println(msg)
}
```

| 구분 | Java `void` | Kotlin `Unit` |
|------|-------------|---------------|
| 타입 여부 | 타입이 아님 | 타입임 |
| 제네릭 사용 | 불가 (`Void` 사용 필요) | 가능 |
| 반환값 | 없음 | `Unit` 싱글턴 객체 |

`Unit`이 타입이라는 점이 제네릭에서 유용합니다.

```kotlin
interface Processor<T> {
    fun process(): T
}

class NoResultProcessor : Processor<Unit> {
    override fun process() {
        // return을 명시할 필요 없음
    }
}
```

### Nothing

`Nothing`은 **정상적으로 끝나지 않는 함수**의 반환 타입입니다. 값을 반환하지 않고 함수 실행이 끝나지 않는다는 것을 명시적으로 나타냅니다.

```kotlin
fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
}
```

`Nothing`은 모든 타입의 하위 타입이므로 식의 일부로 사용할 수 있습니다.

```kotlin
val name = company.name ?: fail("No name")
// fail이 Nothing을 반환하므로 name은 String 타입으로 추론됨
```

---

## 정리

- Kotlin은 원시 타입과 래퍼 타입을 구분하지 않음, 컴파일러가 상황에 따라 자동 선택
- 숫자 타입 간 자동 변환 불가: `toInt()`, `toLong()` 등 명시적 변환 필수
- Nullable 타입(`Int?`)이나 제네릭(`List<Int>`)에서는 박싱 발생
- Any: 모든 널이 아닌 타입의 최상위 타입 (Java Object 대응)
- Unit: 반환값 없는 함수의 타입 (Java void 대응), 제네릭에서 사용 가능
- Nothing: 정상적으로 끝나지 않는 함수의 반환 타입, 모든 타입의 하위 타입

---

## QnA

