---
createdAt: 2026-02-24
modified: 2026-02-24
topic: Kotlin
---

- Kotlin이 불변과 가변을 구분하는 이유
- val과 var의 차이와 val의 주의점
- 불변 컬렉션과 가변 컬렉션 (List vs MutableList)
- 방어적 복사와 컬렉션 안전성
- 불변 객체가 멀티스레드 환경에서 안전한 이유

---

## 왜 불변과 가변을 구분하는가

Kotlin은 **불변(immutable)**을 기본 원칙으로 설계된 언어입니다. 불변 객체를 사용하면 다음과 같은 이점이 있습니다.

1. **예측 가능성**: 값이 변경되지 않으므로 코드의 동작을 추론하기 쉬움
2. **스레드 안전성**: 여러 스레드가 동시에 접근해도 값이 바뀌지 않으므로 동기화 불필요
3. **부수 효과 방지**: 함수가 외부 상태를 변경하지 않으므로 디버깅이 용이
4. **해시 기반 컬렉션 안전성**: [[equals와 hashCode|hashCode]] 값이 변하지 않으므로 HashMap/HashSet에서 안전

---

## val vs var

### val (value)

변경 **불가능한 참조**를 선언합니다. Java의 `final`과 동일합니다.

```kotlin
val name = "John"
name = "Jane"  // 컴파일 에러!
```

### var (variable)

변경 **가능한 참조**를 선언합니다.

```kotlin
var age = 25
age = 26  // OK
```

### val의 주의점: 참조의 불변 != 객체의 불변

`val`은 **참조가 가리키는 대상을 변경할 수 없다**는 의미이지, 객체 내부의 값이 변경 불가능하다는 의미가 아닙니다.

```kotlin
val list = mutableListOf(1, 2, 3)
list.add(4)           // OK! 리스트 내용은 변경 가능
list = mutableListOf() // 컴파일 에러! 참조 자체는 변경 불가
```

```kotlin
val user = User("John", 25)
user.age = 26          // user가 var 프로퍼티를 가지면 OK
user = User("Jane", 30) // 컴파일 에러!
```

---

## 불변 컬렉션 vs 가변 컬렉션

Kotlin은 컬렉션 인터페이스를 **읽기 전용(불변)**과 **가변(mutable)**으로 분리합니다.

### 읽기 전용 컬렉션

```kotlin
val list: List<Int> = listOf(1, 2, 3)
val set: Set<String> = setOf("a", "b")
val map: Map<String, Int> = mapOf("one" to 1)
```

- `add()`, `remove()`, `clear()` 등 수정 메서드 없음
- 읽기 전용이지 완전한 불변이 아님 (아래 참조)

### 가변 컬렉션

```kotlin
val list: MutableList<Int> = mutableListOf(1, 2, 3)
list.add(4)
list.removeAt(0)

val set: MutableSet<String> = mutableSetOf("a", "b")
val map: MutableMap<String, Int> = mutableMapOf("one" to 1)
```

### 컬렉션 인터페이스 계층

```
Collection (읽기 전용)
    ↑
MutableCollection (가변)
    ↑
MutableList, MutableSet

List (읽기 전용)    ←    MutableList (가변)
Set (읽기 전용)     ←    MutableSet (가변)
Map (읽기 전용)     ←    MutableMap (가변)
```

### 읽기 전용 ≠ 완전한 불변

`List`는 **인터페이스 수준에서 수정 메서드를 노출하지 않는 것**이지, 내부 구현이 불변인 것은 아닙니다.

```kotlin
val mutableList = mutableListOf(1, 2, 3)
val readOnlyList: List<Int> = mutableList  // 읽기 전용 타입으로 참조

mutableList.add(4)
println(readOnlyList)  // [1, 2, 3, 4] - 원본이 변경되면 함께 변경됨!
```

이를 방지하려면 **방어적 복사**를 사용합니다.

```kotlin
val mutableList = mutableListOf(1, 2, 3)
val safeCopy: List<Int> = mutableList.toList()  // 새 리스트로 복사

mutableList.add(4)
println(safeCopy)  // [1, 2, 3] - 원본 변경의 영향 없음
```

---

## 불변 객체와 멀티스레드

불변 객체는 생성 후 상태가 변하지 않으므로 여러 쓰레드에서 동시에 읽어도 안전합니다.

```kotlin
// 불변 - 스레드 안전
data class UserState(val name: String, val score: Int)

// 가변 - 스레드 안전하지 않음
class MutableUserState {
    var name: String = ""   // 여러 쓰레드가 동시에 변경 가능
    var score: Int = 0
}
```

Android에서는 [[StateFlow, SharedFlow, Channel|StateFlow]]와 불변 data class를 결합하여 스레드 안전한 상태 관리를 합니다.

```kotlin
data class UiState(val items: List<Item>, val isLoading: Boolean)

class MyViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(UiState(emptyList(), false))
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()

    fun updateItems(newItems: List<Item>) {
        _uiState.value = _uiState.value.copy(items = newItems)  // 새 불변 객체 생성
    }
}
```

---

## 정리

- val: 참조 불변 (재할당 불가), 객체 내부 상태는 변경 가능할 수 있음
- var: 참조 가변 (재할당 가능)
- 불변 컬렉션 (List, Set, Map): 수정 메서드 없음, 인터페이스 수준의 읽기 전용
- 가변 컬렉션 (MutableList, MutableSet, MutableMap): add, remove 등 수정 메서드 제공
- 읽기 전용 ≠ 완전 불변: 원본 MutableList가 변경되면 List 참조도 영향 받음, 방어적 복사로 해결
- 불변 객체의 이점: 예측 가능성, 스레드 안전성, 부수 효과 방지

---

## QnA

