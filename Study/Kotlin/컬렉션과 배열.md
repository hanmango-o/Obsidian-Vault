---
createdAt: 2026-02-28
modified: 2026-02-28
topic: Kotlin
---

- Kotlin 컬렉션의 종류와 생성 방법
- 읽기 전용 컬렉션과 가변 컬렉션의 차이
- 컬렉션 함수형 API (filter, map, groupBy 등)
- 지연 연산(Sequence)의 개념과 활용
- 배열(Array)의 생성과 사용법

---

## 컬렉션 종류

Kotlin은 컬렉션을 **읽기 전용**과 **가변(Mutable)**으로 분리합니다.

### 컬렉션 생성 함수

| 컬렉션 | 읽기 전용 | 가변 |
|--------|----------|------|
| List | `listOf()` | `mutableListOf()`, `arrayListOf()` |
| Set | `setOf()` | `mutableSetOf()`, `hashSetOf()`, `linkedSetOf()`, `sortedSetOf()` |
| Map | `mapOf()` | `mutableMapOf()`, `hashMapOf()`, `linkedMapOf()`, `sortedMapOf()` |

```kotlin
val list = listOf(1, 2, 3)
val mutableList = mutableListOf(1, 2, 3)

val set = setOf("a", "b", "c")
val map = mapOf("key1" to 1, "key2" to 2)
```

### 빈 컬렉션 생성

```kotlin
val emptyList = emptyList<String>()
val emptySet = emptySet<Int>()
val emptyMap = emptyMap<String, Int>()
```

### 읽기 전용 vs 가변 컬렉션

[[불변과 가변|불변과 가변]]에서 다뤘듯이, 읽기 전용 컬렉션은 수정 메서드를 노출하지 않을 뿐 내부 구현이 불변인 것은 아닙니다.

```kotlin
val mutable = mutableListOf(1, 2, 3)
val readOnly: List<Int> = mutable  // 읽기 전용 타입으로 참조

mutable.add(4)
println(readOnly)  // [1, 2, 3, 4] - 원본 변경에 영향 받음
```

---

## 컬렉션 함수형 API

Kotlin은 컬렉션을 다루는 풍부한 함수형 API를 제공합니다.

### filter와 map

`filter`는 조건에 맞는 원소만 걸러내고, `map`은 원소를 변환합니다.

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

val evens = numbers.filter { it % 2 == 0 }       // [2, 4]
val doubled = numbers.map { it * 2 }              // [2, 4, 6, 8, 10]
val evenDoubled = numbers.filter { it % 2 == 0 }
                         .map { it * 2 }          // [4, 8]
```

### all, any, none, count, find

| 함수 | 설명 | 반환 타입 |
|------|------|----------|
| `all` | 모든 원소가 조건을 만족하는지 | Boolean |
| `any` | 하나라도 조건을 만족하는지 | Boolean |
| `none` | 조건을 만족하는 원소가 없는지 | Boolean |
| `count` | 조건을 만족하는 원소 수 | Int |
| `find` | 조건을 만족하는 첫 번째 원소 | T? |

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31))

people.all { it.age >= 27 }    // true
people.any { it.age > 30 }     // true
people.count { it.age > 30 }   // 1
people.find { it.age > 30 }    // Person("Bob", 31)
```

### groupBy

컬렉션을 특정 기준으로 그룹핑합니다.

```kotlin
val people = listOf(
    Person("Alice", 29),
    Person("Bob", 31),
    Person("Carol", 29)
)

val grouped = people.groupBy { it.age }
// {29=[Alice, Carol], 31=[Bob]}
```

### flatMap과 flatten

```kotlin
val books = listOf(
    Book("Book1", listOf("Author1", "Author2")),
    Book("Book2", listOf("Author2", "Author3"))
)

val authors = books.flatMap { it.authors }.toSet()
// [Author1, Author2, Author3]
```

- `flatMap`: 각 원소를 컬렉션으로 변환한 뒤 하나의 리스트로 펼침
- `flatten`: 이중 컬렉션을 하나의 리스트로 펼침

### 기타 유용한 함수

| 함수 | 설명 | 예시 |
|------|------|------|
| `forEach` | 각 원소에 대해 작업 수행 | `list.forEach { println(it) }` |
| `forEachIndexed` | 인덱스와 함께 순회 | `list.forEachIndexed { i, v -> ... }` |
| `sorted()` / `sortedBy` | 정렬 | `list.sortedBy { it.name }` |
| `distinct` | 중복 제거 | `list.distinct()` |
| `take` / `drop` | 앞에서 가져오기 / 버리기 | `list.take(3)` |
| `zip` | 두 컬렉션을 쌍으로 묶기 | `listA.zip(listB)` |
| `associate` | Map으로 변환 | `list.associate { it.name to it.age }` |

---

## 지연 연산: Sequence

컬렉션 함수를 체이닝하면 매 단계마다 **중간 결과 컬렉션**이 생성됩니다. `Sequence`를 사용하면 이를 방지하고 **지연 연산(lazy evaluation)**으로 처리할 수 있습니다.

### 즉시 연산 vs 지연 연산

```kotlin
// 즉시 연산: 중간 리스트 2개 생성
val result = listOf(1, 2, 3, 4)
    .filter { it % 2 == 0 }  // 중간 리스트 [2, 4]
    .map { it * 2 }           // 중간 리스트 [4, 8]

// 지연 연산: 중간 리스트 없이 처리
val result = listOf(1, 2, 3, 4)
    .asSequence()
    .filter { it % 2 == 0 }
    .map { it * 2 }
    .toList()                 // 최종 결과만 생성
```

### Sequence의 동작 방식

| 구분 | 컬렉션 (즉시 연산) | Sequence (지연 연산) |
|------|-------------------|---------------------|
| 처리 순서 | 수평적 (함수 단위) | 수직적 (원소 단위) |
| 중간 결과 | 매 단계마다 생성 | 생성하지 않음 |
| 성능 | 소규모 데이터에 적합 | 대규모 데이터에 적합 |
| 최종 연산 | 불필요 | 필수 (`toList()`, `first()` 등) |

```kotlin
// Sequence는 원소 단위로 처리
sequenceOf(1, 2, 3, 4)
    .filter { println("filter $it"); it % 2 == 0 }
    .map { println("map $it"); it * 2 }
    .toList()
// filter 1 → filter 2 → map 2 → filter 3 → filter 4 → map 4
```

### Sequence 생성

```kotlin
// 컬렉션에서 변환
val seq = listOf(1, 2, 3).asSequence()

// generateSequence로 생성
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }.toList()
```

---

## 배열(Array)

Kotlin에서 배열은 `Array` 클래스로 표현됩니다.

### 배열 생성

```kotlin
val arr1 = arrayOf(1, 2, 3)
val arr2 = arrayOfNulls<String>(5)      // [null, null, null, null, null]
val arr3 = Array(5) { i -> i * 2 }      // [0, 2, 4, 6, 8]
```

### 원시 타입 배열

박싱 오버헤드를 피하기 위해 원시 타입 전용 배열 클래스가 제공됩니다.

| 클래스 | 생성 함수 | JVM 매핑 |
|--------|----------|----------|
| `IntArray` | `intArrayOf()` | `int[]` |
| `LongArray` | `longArrayOf()` | `long[]` |
| `DoubleArray` | `doubleArrayOf()` | `double[]` |
| `FloatArray` | `floatArrayOf()` | `float[]` |
| `BooleanArray` | `booleanArrayOf()` | `boolean[]` |
| `CharArray` | `charArrayOf()` | `char[]` |
| `ByteArray` | `byteArrayOf()` | `byte[]` |

```kotlin
val intArr = intArrayOf(1, 2, 3)
val doubleArr = DoubleArray(5) { i -> i * 0.5 }
```

### 배열과 컬렉션 변환

```kotlin
val list = listOf(1, 2, 3)
val arr = list.toIntArray()     // List → IntArray
val backToList = arr.toList()   // IntArray → List
```

배열에서도 `filter`, `map` 등 컬렉션 함수형 API를 동일하게 사용할 수 있습니다.

---

## 정리

- 컬렉션은 읽기 전용(`List`, `Set`, `Map`)과 가변(`MutableList`, `MutableSet`, `MutableMap`)으로 분리
- `filter`, `map`, `groupBy`, `flatMap` 등 풍부한 함수형 API 제공
- Sequence: 지연 연산으로 대규모 데이터 처리 시 중간 컬렉션 생성 방지
- 원시 타입 배열(`IntArray`, `DoubleArray` 등): 박싱 오버헤드 없이 사용 가능
- `asSequence()`, `toList()`, `toIntArray()` 등으로 컬렉션/시퀀스/배열 간 변환 가능

---

## QnA

