---
cssclasses:
  - cornell-left
  - cornell-livepreview
---
* 1. 이름 붙은 인자(Named Parameter)
* Kotlin에서 함수안에 인자를 전달할 때 전달하는 인자 중 일부(또는 전체)의 이름을 명시할 수 있음
* 일반적으로 이름을 명시하지 않은 인자를 위치 인자(positional argument)라고 함
```kotlin
fun foo(a: Int, b: Int, c: Int)

foo(a = 1, b = 2, c = 3) // Named Parameter 사용
```
* Named Parameter를 사용할때에는 인자의 순서는 중요하지 않음
* 다만 아래 규칙이 준수되어야 함
* (표)
	* “중간 인자 하나만” 이름 붙여서 넘기기
	* 이름 붙은 인자(named argument) 뒤에는 위치 인자(positional argument)를 쓸 수 없음
	* 가능한 경우 1: 앞은 위치, 중간부터 이름
	* 가능한 경우 2: 기본값(default parameter) 활용
	* 가능한 경우 3: 전부 이름으로
```kotlin
foo(a = 1, b = 2, c = 3) // 가능
foo(1, b = 2, c =3) // 가능
foo(b = 2, c = 3, a = 1) // 가능
foo(1, c = 3, b = 2) // 가능
foo(1, b = 2, 3) // 불가능
```

* 2. 디폴트 파라미터(Default Parameter)
* Kotlin에서는 함수 선언 시 파라미터의 default값을 지정할 수 있음
* 이를 통해 기존 자바에서 발생하던 overloading 메서드가 너무 많아지는 문제를 해결함
```kotlin
fun foo(a: Int = 1, b: Int, c: Int = 3)
```
기본 규칙
- **위치 인자(positional argument)는 앞에서부터 순서대로 매핑**
- **중간에 있는 파라미터는 건너뛸 수 없음**
default parameter가 중간에 있으면
`fun foo(a: Int, b: Int = 2, c: Int) {}  foo(1, 3)     // ❌ b에 3이 들어가고 c가 없음 foo(1, c = 3) // ✅ named 필요`

default parameter를 맨 뒤에 두면
`fun foo(a: Int, c: Int, b: Int = 2) {}  foo(1, 3) // ✅ a=1, c=3, b=2`
결론
default parameter는 항상 뒤에 선언한다
→ positional 호출도 되고, named 호출도 자연스럽다

* 3. 최상위 함수와 프로퍼티
* 3-1. 최상위 함수
* Java에서는 모든 코드를 클래스의 메서드로 작성해야함
* 그래서 이로 인해 정적(static) 메서드를 따로 모아두는 역할을 담당하는 클래스들이 생김(Collections에 Util)
* Kotlin에서는 함수를 최상위 수준, 즉 클래스의 밖에 두는게 가능함 그래서 이런 문제가 안생김
* 이런 최상위 함수는 실행 시 컴파일러가 새로운 클래스로 정의해줌
	* 그래서 JVM에 의해 돌아감
	* 클래스의 이름은 해당 최상위 함수가 선언된 패키지 명이 됨
	* @JvmName 애너테이션을 통해 이 클래스 이름을 바꿀 수 있음
* 3-2. 최상위 프로퍼티
* 프로퍼티도 최상위에 놓일 수 있음
```kotlin
var opCount = 0 // 최상위 프로퍼티 선언

fun performOperation() {
	opCount++
}
```
* 이렇게 선언된 최상위 프로퍼티는 정적(static) 필드에 저장됨
	* 최상위 함수와 마찬가지로 실행 시 컴파일러가 새로운 클래스로 정의해줌
* 최상위 프로퍼티도 다른 프로퍼티처럼 접근자 메서드를 통해 자바 코드에 노출됨
	* val : getter, var : getter, setter
* 최상위 프로퍼티를 보면 겉으로는 상수처럼 생겼는데 접근자 메서드를 제공한다는 건 자연스럽지 못한 느낌
	* 만약 접근자 메서드를 

> [!cue] Sample of a Summary



> [!summary] Title for summary

