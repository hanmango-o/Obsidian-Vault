---
cssclasses:
  - cornell-left
  - cornell-livepreview
---
* 1. 이름 붙은 인자(Named Parameter)
* Kotlin에서 함수안에 인자를 전달할 때 전달하는 인자 중 일부(또는 전체)의 이름을 명시할 수 있음
* 일반적으로 이름을 명시하지 않은 인자를 위치 인자(positional argument)라고 함
```kotlin
fun foo(a: Int, b: Int, c: Int)

foo(a = 1, b = 2, c = 3) // Named Parameter 사용
```
* Named Parameter를 사용할때에는 인자의 순서는 중요하지 않음
* 다만 아래 규칙이 준수되어야 함
* (표)
	* “중간 인자 하나만” 이름 붙여서 넘기기
	* 이름 붙은 인자(named argument) 뒤에는 위치 인자(positional argument)를 쓸 수 없음
	* 가능한 경우 1: 앞은 위치, 중간부터 이름
	* 가능한 경우 2: 기본값(default parameter) 활용
	* 가능한 경우 3: 전부 이름으로
```kotlin
foo(a = 1, b = 2, c = 3) // 가능
foo(1, b = 2, c =3) // 가능
foo(b = 2, c = 3, a = 1) // 가능
foo(1, c = 3, b = 2) // 가능
foo(1, b = 2, 3) // 불가능
```

* 2. 디폴트 파라미터(Default Parameter)
* Kotlin에서는 함수 선언 시 파라미터의 default값을 지정할 수 있음
* 이를 통해 기존 자바에서 발생하던 overloading 메서드가 너무 많아지는 문제를 해결함
```kotlin
fun foo(a: Int = 1, b: Int, c: Int = 3)
```
기본 규칙
- **위치 인자(positional argument)는 앞에서부터 순서대로 매핑**
- **중간에 있는 파라미터는 건너뛸 수 없음**
default parameter가 중간에 있으면
`fun foo(a: Int, b: Int = 2, c: Int) {}  foo(1, 3)     // ❌ b에 3이 들어가고 c가 없음 foo(1, c = 3) // ✅ named 필요`

default parameter를 맨 뒤에 두면
`fun foo(a: Int, c: Int, b: Int = 2) {}  foo(1, 3) // ✅ a=1, c=3, b=2`
결론
default parameter는 항상 뒤에 선언한다
→ positional 호출도 되고, named 호출도 자연스럽다

* 3. 최상위 함수와 프로퍼티
* 3-1. 최상위 함수
* Java에서는 모든 코드를 클래스의 메서드로 작성해야함
* 그래서 이로 인해 정적(static) 메서드를 따로 모아두는 역할을 담당하는 클래스들이 생김(Collections에 Util)
* Kotlin에서는 함수를 최상위 수준, 즉 클래스의 밖에 두는게 가능함 그래서 이런 문제가 안생김
* 이런 최상위 함수는 실행 시 컴파일러가 새로운 클래스로 정의해줌
	* 그래서 JVM에 의해 돌아감
	* 클래스의 이름은 해당 최상위 함수가 선언된 패키지 명이 됨
	* @JvmName 애너테이션을 통해 이 클래스 이름을 바꿀 수 있음
* 3-2. 최상위 프로퍼티
* 프로퍼티도 최상위에 놓일 수 있음
```kotlin
var opCount = 0 // 최상위 프로퍼티 선언

fun performOperation() {
	opCount++
}
```
* 이렇게 선언된 최상위 프로퍼티는 정적(static) 필드에 저장됨
	* 최상위 함수와 마찬가지로 실행 시 컴파일러가 새로운 클래스로 정의해줌
* 최상위 프로퍼티도 다른 프로퍼티처럼 접근자 메서드를 통해 자바 코드에 노출됨
	* val : getter, var : getter, setter
* 최상위 프로퍼티를 보면 겉으로는 상수처럼 생겼지만 실제로는 접근자로 접근하며 상수가 아님
* 만약 상수로 최상위 프로퍼티를 쓰고 싶다면 앞에 const를 붙여주면됨
- 최상위 프로퍼티는 `val` 또는 `const val`로 선언할 수 있음
- `val`
    
    - 값이 런타임에 결정됨
        
    - getter가 생성됨
        
    - 함수 호출 결과 사용 가능
        
    - 객체, 컬렉션 등 모든 타입 가능
        
    - annotation 인자로 사용 불가
        
    - Java에서는 getter를 통해 접근
        
- `const val`
    
    - 값이 컴파일 타임에 결정됨
        
    - 바이트코드에 값이 직접 삽입됨
        
    - getter가 생성되지 않음
        
    - 기본 타입과 String만 가능
        
    - 리터럴 값만 허용
        
    - annotation 인자로 사용 가능
        
    - when, case 조건에 사용 가능
        
    - Java에서는 static final 상수로 노출됨
        
- `val`을 사용해야 하는 경우
    
    - 계산이 필요한 값
        
    - 함수 호출 결과
        
    - 객체나 컬렉션
        
    - 실행 시점에 값이 정해지는 경우
        
- `const val`을 사용해야 하는 경우
    
    - 변하지 않는 상수
        
    - 설정 값, 키, 코드 값
        
    - annotation, when, case에 사용해야 하는 값
        
- 핵심 정리
    
    - `const val`은 컴파일 타임 상수
        
    - `val`은 런타임 값

* 4. 확장 함수와 확장 프로퍼티
* 4-1. 확장 함수(Extension Function)
* 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스 밖에 선언된 함수
* 확장함수를 만들려면 추가하려는 함수 ㅣㅇ름 앞에 함수가 확장할 클래스의 이름을 덧붙이기만 하면 됨
* 클래스 이름을 수신 객체 타입(Receiver Type), 확장 함수가 호출되는 대상 값을 수신 객체(Receiver Object)라고 함
* (예시 코드 필요, 코드내 주석 필요)
* 확장함수 본문에서도 this를 쓸 수 있음(예시 코드 필요)
* 그리고 일반 메서드 처럼 this를 생략할 수도 있음
* 확장함수 내부에서는 수신 객체의 메서드나 프로퍼티는 이용할 수 있어도, 클래스 내부에서만 사용할 수 있는 private 멤버나 protected멤버를 사용할 수 없음
	* 이게 일반 메서드와의 차이점
	* 이로 인해 확장 하수가 캡슐화를 깨지 않는다
* 내부적으로 확장함수는 수신 객체를 첫번째 인자로 받는 정적(static) 메서드임
	* 그래서 Java에서도 Kotlin에 정의한 확장함수를 사용할 때에는 static 메서드 호출처럼 쓰고 수신객체를 메서드의 첫번째 인자로 넣어주면 됨(예시 코드 필요)
* 확장함수는 오버라이드가 불가능함
* 일반적으로 함수를 확장하면 overried가 가능하지만, 확장 함수는 클래스의 일부가 아닌 클래스 밖에 선언되기에 불가능함
* 이는 확장함수를 호출할 때 동적 디스패치(dynamic dispatch)가 아닌 정적 디스패치(static dispatch)를 쓰기 때문임
* 동적 디스패치 와 정적 디스패치의 차이 (간단히 표로 서술 필요)
* 그로 인해 확장함수 호출 시 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장함수가 호출될지 결정됨
* 즉 확장함수를 오버라이드 할 수 없는 이유는 kotlin은 확장함수를 정적으로 결정하기 때문
* 4-2. 확장 프로퍼티
* - 확장 프로퍼티는 **기존 클래스에 프로퍼티가 있는 것처럼 보이게 하는 문법**임
    
- 실제로 **필드를 추가하지는 않음**
    
- 선언 형태
    
    `val String.lastChar: Char     get() = this[length - 1]`
    
- 동작 방식
    
    - 내부적으로는 **getter 함수**로만 동작함
        
    - backing field를 가질 수 없음
        
- 제약 사항
    
    - 초기화 블록 사용 불가
        
    - `var`로 선언하더라도 실제 저장 공간 없음
        
    - setter는 다른 계산 로직일 뿐임
        
- 접근 방식
    
    - 인스턴스 멤버처럼 접근 가능
        
    
    `val c = "hello".lastChar`
    
- 바인딩 특성
    
    - **정적 바인딩**
        
    - 실제 객체 타입이 아니라 **선언된 타입 기준**으로 호출됨
        
- 사용 목적
    
    - 읽기 쉬운 계산 프로퍼티 제공
        
    - 유틸 함수의 가독성 개선
        
    - 도메인 의미를 드러내는 보조 속성 추가
        
- 핵심 정리
    
    - 확장 프로퍼티는 필드가 아님
        
    - 문법적으로만 프로퍼티처럼 보이는 getter/setter 함수임

> [!cue] Sample of a Summary



> [!summary] Title for summary

