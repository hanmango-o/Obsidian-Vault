---
cssclasses:
  - cornell-left
  - cornell-livepreview
---

## 1. 이름 붙은 인자(Named Parameter)

Kotlin에서 함수에 인자를 전달할 때 전달하는 인자 중 일부(또는 전체)의 이름을 명시할 수 있습니다. 일반적으로 이름을 명시하지 않은 인자를 **위치 인자(positional argument)**라고 합니다.

```kotlin
fun foo(a: Int, b: Int, c: Int)

foo(a = 1, b = 2, c = 3)  // Named Parameter 사용
```

### 1-1. Named Parameter 사용 규칙

Named Parameter를 사용할 때에는 인자의 순서는 중요하지 않습니다. 다만 아래 규칙이 준수되어야 합니다.

| 규칙 | 설명 | 예시 |
|------|------|------|
| ✅ 전부 이름으로 | 순서 무관하게 사용 가능 | `foo(a = 1, b = 2, c = 3)` |
| ✅ 앞은 위치, 뒤는 이름 | 위치 인자는 앞에서부터 순서대로 | `foo(1, b = 2, c = 3)` |
| ✅ 이름으로 순서 변경 | 이름 붙은 인자는 순서 무관 | `foo(b = 2, c = 3, a = 1)` |
| ✅ 위치와 이름 혼용 | 위치 인자 후 이름 인자 | `foo(1, c = 3, b = 2)` |
| ❌ 이름 뒤 위치 불가 | 이름 붙은 인자 뒤에 위치 인자 사용 불가 | `foo(1, b = 2, 3)` ← 오류 |

```kotlin
foo(a = 1, b = 2, c = 3)  // ✅ 가능
foo(1, b = 2, c = 3)      // ✅ 가능
foo(b = 2, c = 3, a = 1)  // ✅ 가능
foo(1, c = 3, b = 2)      // ✅ 가능
foo(1, b = 2, 3)          // ❌ 불가능: 이름 붙은 인자 뒤에 위치 인자 사용
```

**핵심 규칙**: 이름 붙은 인자(named argument) 뒤에는 위치 인자(positional argument)를 쓸 수 없습니다.

## 2. 디폴트 파라미터(Default Parameter)

Kotlin에서는 함수 선언 시 파라미터의 기본값을 지정할 수 있습니다. 이를 통해 기존 Java에서 발생하던 오버로딩(overloading) 메서드가 너무 많아지는 문제를 해결합니다.

```kotlin
fun foo(a: Int = 1, b: Int, c: Int = 3)
```

### 2-1. Default Parameter 사용 규칙

| 상황 | 설명 | 해결 방법 |
|------|------|----------|
| Default가 중간에 위치 | 위치 인자만으로는 건너뛸 수 없음 | Named Parameter 사용 필수 |
| Default가 뒤에 위치 | 위치 인자만으로도 호출 가능 | 권장되는 방식 |

#### Default Parameter가 중간에 있는 경우

```kotlin
fun foo(a: Int, b: Int = 2, c: Int) {}

foo(1, 3)     // ❌ b에 3이 들어가고 c가 없어서 오류
foo(1, c = 3) // ✅ Named Parameter 필요
```

위치 인자(positional argument)는 앞에서부터 순서대로 매핑되므로, 중간에 있는 파라미터는 건너뛸 수 없습니다.

#### Default Parameter를 맨 뒤에 두는 경우

```kotlin
fun foo(a: Int, c: Int, b: Int = 2) {}

foo(1, 3)  // ✅ a=1, c=3, b=2 (기본값 사용)
```

### 2-2. 결론

**Default Parameter는 항상 뒤에 선언하는 것이 좋습니다.**
- 위치 인자(positional) 호출도 가능합니다
- Named Parameter 호출도 자연스럽습니다

## 3. 최상위 함수와 프로퍼티

### 3-1. 최상위 함수

Java에서는 모든 코드를 클래스의 메서드로 작성해야 합니다. 그래서 이로 인해 정적(static) 메서드를 따로 모아두는 역할을 담당하는 유틸리티 클래스들이 생깁니다(예: `Collections`, `StringUtils`).

Kotlin에서는 함수를 최상위 수준, 즉 클래스 밖에 두는 것이 가능합니다. 그래서 이런 문제가 발생하지 않습니다.

```kotlin
// join.kt 파일
package strings

fun joinToString(...): String { ... }
```

#### 최상위 함수의 동작 원리

이런 최상위 함수는 실행 시 컴파일러가 새로운 클래스로 정의해줍니다.
- JVM에 의해 실행됩니다
- 클래스의 이름은 해당 최상위 함수가 선언된 파일명이 됩니다
- `@JvmName` 애너테이션을 통해 이 클래스 이름을 바꿀 수 있습니다

```kotlin
// join.kt
@file:JvmName("StringFunctions")
package strings

fun joinToString(...): String { ... }
```

### 3-2. 최상위 프로퍼티

프로퍼티도 최상위에 놓일 수 있습니다.

```kotlin
var opCount = 0  // 최상위 프로퍼티 선언

fun performOperation() {
	opCount++
}
```

이렇게 선언된 최상위 프로퍼티는 정적(static) 필드에 저장됩니다.
- 최상위 함수와 마찬가지로 실행 시 컴파일러가 새로운 클래스로 정의해줍니다

#### 최상위 프로퍼티의 접근 방식

최상위 프로퍼티도 다른 프로퍼티처럼 접근자 메서드를 통해 Java 코드에 노출됩니다.
- `val`: getter
- `var`: getter, setter

### 3-3. val과 const val의 차이

최상위 프로퍼티를 보면 겉으로는 상수처럼 생겼지만 실제로는 접근자로 접근하며 상수가 아닙니다. 만약 상수로 최상위 프로퍼티를 쓰고 싶다면 앞에 `const`를 붙여주면 됩니다.

| 구분 | `val` | `const val` |
|------|-------|-------------|
| **값 결정 시점** | 런타임 | 컴파일 타임 |
| **Getter 생성** | ✅ 생성됨 | ❌ 생성 안 됨 |
| **바이트코드** | getter 호출 | 값이 직접 삽입 |
| **사용 가능 타입** | 모든 타입 | 기본 타입과 String만 |
| **함수 호출 결과** | ✅ 가능 | ❌ 불가능 (리터럴만) |
| **Annotation 인자** | ❌ 불가능 | ✅ 가능 |
| **when 조건** | ❌ 불가능 | ✅ 가능 |
| **Java 노출** | getter를 통해 접근 | `public static final` 상수 |

#### 사용 예시

```kotlin
// val - 런타임에 결정
val PI = Math.PI
val list = listOf(1, 2, 3)
val result = calculateValue()

// const val - 컴파일 타임 상수
const val MAX_COUNT = 100
const val API_KEY = "abc123"
const val VERSION = "1.0.0"
```

#### 언제 사용해야 하는가?

| 사용 상황 | 선택 |
|----------|------|
| 계산이 필요한 값 | `val` |
| 함수 호출 결과 | `val` |
| 객체나 컬렉션 | `val` |
| 실행 시점에 값이 정해지는 경우 | `val` |
| 변하지 않는 상수 | `const val` |
| 설정 값, 키, 코드 값 | `const val` |
| Annotation, when에 사용해야 하는 값 | `const val` |

**핵심 정리**:
- `const val`은 컴파일 타임 상수입니다
- `val`은 런타임 값입니다

## 4. 확장 함수와 확장 프로퍼티

### 4-1. 확장 함수(Extension Function)

확장 함수는 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스 밖에 선언된 함수입니다.

확장 함수를 만들려면 추가하려는 함수 이름 앞에 함수가 확장할 클래스의 이름을 덧붙이기만 하면 됩니다.

```kotlin
// String 클래스에 lastChar 확장 함수 추가
fun String.lastChar(): Char = this[this.length - 1]

// 사용
val c = "Kotlin".lastChar()  // 'n' 반환
```

#### 용어 정리

| 용어 | 의미 | 예시에서 |
|------|------|----------|
| **수신 객체 타입**<br>(Receiver Type) | 확장할 클래스의 이름 | `String` |
| **수신 객체**<br>(Receiver Object) | 확장 함수가 호출되는 대상 값 | `"Kotlin"` |

#### this 사용

확장 함수 본문에서도 `this`를 쓸 수 있습니다.

```kotlin
fun String.lastChar(): Char = this[this.length - 1]

// this 생략 가능
fun String.lastChar(): Char = this[length - 1]

// 더 간결하게
fun String.lastChar(): Char = get(length - 1)
```

일반 메서드처럼 `this`를 생략할 수도 있습니다.

### 4-2. 확장 함수의 특징

#### 캡슐화 유지

확장 함수 내부에서는 수신 객체의 메서드나 프로퍼티를 이용할 수 있어도, 클래스 내부에서만 사용할 수 있는 `private` 멤버나 `protected` 멤버를 사용할 수 없습니다.

| 구분 | 일반 메서드 | 확장 함수 |
|------|-----------|----------|
| `public` 멤버 접근 | ✅ 가능 | ✅ 가능 |
| `protected` 멤버 접근 | ✅ 가능 | ❌ 불가능 |
| `private` 멤버 접근 | ✅ 가능 | ❌ 불가능 |
| 캡슐화 | 내부 구현 접근 가능 | 캡슐화를 깨지 않음 |

이것이 일반 메서드와의 차이점이며, 이로 인해 확장 함수가 캡슐화를 깨지 않습니다.

#### 내부 동작 원리

내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적(static) 메서드입니다.

```kotlin
// Kotlin 확장 함수
fun String.lastChar(): Char = this[length - 1]

// Java에서 사용
char c = StringUtilKt.lastChar("Java");  // 수신 객체를 첫 번째 인자로 전달
```

그래서 Java에서도 Kotlin에 정의한 확장 함수를 사용할 때에는 static 메서드 호출처럼 쓰고 수신 객체를 메서드의 첫 번째 인자로 넣어주면 됩니다.

### 4-3. 확장 함수는 오버라이드 불가능

확장 함수는 오버라이드가 불가능합니다. 일반적으로 함수를 확장하면 오버라이드가 가능하지만, 확장 함수는 클래스의 일부가 아닌 클래스 밖에 선언되기에 불가능합니다.

이는 확장 함수를 호출할 때 **정적 디스패치(static dispatch)**를 사용하기 때문입니다.

#### 동적 디스패치 vs 정적 디스패치

| 구분 | 동적 디스패치<br>(Dynamic Dispatch) | 정적 디스패치<br>(Static Dispatch) |
|------|-----------------------------------|----------------------------------|
| **결정 시점** | 런타임 | 컴파일 타임 |
| **결정 기준** | 실제 객체 타입 | 선언된 변수 타입 |
| **오버라이드** | ✅ 가능 | ❌ 불가능 |
| **사용 대상** | 일반 메서드 | 확장 함수 |
| **성능** | 약간 느림 | 빠름 |

```kotlin
open class View
class Button : View()

fun View.click() = println("View clicked")
fun Button.click() = println("Button clicked")

val view: View = Button()
view.click()  // "View clicked" 출력
              // 정적 타입이 View이므로 View.click() 호출
```

그로 인해 확장 함수 호출 시 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정됩니다.

**즉, 확장 함수를 오버라이드할 수 없는 이유는 Kotlin이 확장 함수를 정적으로 결정하기 때문입니다.**

### 4-4. 확장 프로퍼티

확장 프로퍼티는 **기존 클래스에 프로퍼티가 있는 것처럼 보이게 하는 문법**입니다. 실제로 **필드를 추가하지는 않습니다**.

#### 선언 형태

```kotlin
val String.lastChar: Char
    get() = this[length - 1]

var StringBuilder.lastChar: Char
    get() = this[length - 1]
    set(value) {
        this.setCharAt(length - 1, value)
    }
```

#### 동작 방식과 특성

| 특성 | 설명 |
|------|------|
| **실제 구현** | 내부적으로는 getter 함수로만 동작 |
| **Backing Field** | 가질 수 없음 |
| **초기화 블록** | 사용 불가 |
| **var 선언** | 가능하지만 실제 저장 공간 없음 |
| **Setter** | 다른 계산 로직일 뿐 |
| **바인딩** | 정적 바인딩 (선언된 타입 기준) |

#### 접근 방식

```kotlin
val c = "hello".lastChar  // 'o'

val sb = StringBuilder("Kotlin")
sb.lastChar = '!'  // "Kotlin!"로 변경
```

인스턴스 멤버처럼 접근할 수 있습니다.

#### 제약 사항

```kotlin
// ❌ 불가능: 초기화 불가
val String.lastChar: Char = 'a'  // 오류

// ✅ 가능: getter 반드시 필요
val String.lastChar: Char
    get() = this[length - 1]
```

#### 사용 목적

- 읽기 쉬운 계산 프로퍼티 제공
- 유틸 함수의 가독성 개선
- 도메인 의미를 드러내는 보조 속성 추가

**핵심 정리**:
- 확장 프로퍼티는 필드가 아닙니다
- 문법적으로만 프로퍼티처럼 보이는 getter/setter 함수입니다

> [!cue] Sample of a Summary

> [!summary] Title for summary

